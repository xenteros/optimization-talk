{"traceEvents": [{"ph": "M", "pid": 29736, "tid": 29736, "name": "process_name", "args": {"name": "MainProcess"}}, {"ph": "M", "pid": 29736, "tid": 14104, "name": "thread_name", "args": {"name": "MainThread"}}, {"pid": 29736, "tid": 14104, "ts": 2292618405684.6, "dur": 0.3, "name": "dict.keys", "ph": "X", "cat": "FEE"}, {"pid": 29736, "tid": 14104, "ts": 2292618405687.5, "dur": 10.9, "name": "_validate_input (C:\\workspace\\projects\\talk\\venv\\Lib\\site-packages\\onnxruntime\\capi\\onnxruntime_inference_collection.py:192)", "ph": "X", "cat": "FEE"}, {"pid": 29736, "tid": 14104, "ts": 2292618405699.8, "dur": 1.6, "name": "<listcomp> (C:\\workspace\\projects\\talk\\venv\\Lib\\site-packages\\onnxruntime\\capi\\onnxruntime_inference_collection.py:218)", "ph": "X", "cat": "FEE"}, {"pid": 29736, "tid": 14104, "ts": 2292618405703.0, "dur": 59458.4, "name": "onnxruntime.capi.onnxruntime_pybind11_state.run", "ph": "X", "cat": "FEE"}, {"pid": 29736, "tid": 14104, "ts": 2292618405683.9, "dur": 59478.6, "name": "run (C:\\workspace\\projects\\talk\\venv\\Lib\\site-packages\\onnxruntime\\capi\\onnxruntime_inference_collection.py:202)", "ph": "X", "cat": "FEE"}], "viztracer_metadata": {"version": "0.16.2", "overflow": false}, "file_info": {"files": {"C:\\workspace\\projects\\talk\\venv\\Lib\\site-packages\\onnxruntime\\capi\\onnxruntime_inference_collection.py": ["# -------------------------------------------------------------------------\n# Copyright (c) Microsoft Corporation. All rights reserved.\n# Licensed under the MIT License.\n# --------------------------------------------------------------------------\nfrom __future__ import annotations\n\nimport collections\nimport collections.abc\nimport os\nimport typing\nimport warnings\nfrom typing import Any, Sequence\n\nfrom onnxruntime.capi import _pybind_state as C\n\nif typing.TYPE_CHECKING:\n    import onnxruntime\n\n\ndef get_ort_device_type(device_type: str, device_index) -> C.OrtDevice:\n    if device_type == \"cuda\":\n        return C.OrtDevice.cuda()\n    elif device_type == \"cann\":\n        return C.OrtDevice.cann()\n    elif device_type == \"cpu\":\n        return C.OrtDevice.cpu()\n    elif device_type == \"dml\":\n        return C.OrtDevice.dml()\n    elif device_type == \"ort\":\n        return C.get_ort_device(device_index).device_type()\n    else:\n        raise Exception(\"Unsupported device type: \" + device_type)\n\n\ndef check_and_normalize_provider_args(\n    providers: Sequence[str | tuple[str, dict[Any, Any]]] | None,\n    provider_options: Sequence[dict[Any, Any]] | None,\n    available_provider_names: Sequence[str],\n):\n    \"\"\"\n    Validates the 'providers' and 'provider_options' arguments and returns a\n        normalized version.\n\n    :param providers: Optional sequence of providers in order of decreasing\n        precedence. Values can either be provider names or tuples of\n        (provider name, options dict).\n    :param provider_options: Optional sequence of options dicts corresponding\n        to the providers listed in 'providers'.\n    :param available_provider_names: The available provider names.\n\n    :return: Tuple of (normalized 'providers' sequence, normalized\n        'provider_options' sequence).\n\n    'providers' can contain either names or names and options. When any options\n        are given in 'providers', 'provider_options' should not be used.\n\n    The normalized result is a tuple of:\n    1. Sequence of provider names in the same order as 'providers'.\n    2. Sequence of corresponding provider options dicts with string keys and\n        values. Unspecified provider options yield empty dicts.\n    \"\"\"\n    if providers is None:\n        return [], []\n\n    provider_name_to_options = collections.OrderedDict()\n\n    def set_provider_options(name, options):\n        if name not in available_provider_names:\n            warnings.warn(\n                \"Specified provider '{}' is not in available provider names.\"\n                \"Available providers: '{}'\".format(name, \", \".join(available_provider_names))\n            )\n\n        if name in provider_name_to_options:\n            warnings.warn(f\"Duplicate provider '{name}' encountered, ignoring.\")\n            return\n\n        normalized_options = {str(key): str(value) for key, value in options.items()}\n        provider_name_to_options[name] = normalized_options\n\n    if not isinstance(providers, collections.abc.Sequence):\n        raise ValueError(\"'providers' should be a sequence.\")\n\n    if provider_options is not None:\n        if not isinstance(provider_options, collections.abc.Sequence):\n            raise ValueError(\"'provider_options' should be a sequence.\")\n\n        if len(providers) != len(provider_options):\n            raise ValueError(\"'providers' and 'provider_options' should be the same length if both are given.\")\n\n        if not all([isinstance(provider, str) for provider in providers]):\n            raise ValueError(\"Only string values for 'providers' are supported if 'provider_options' is given.\")\n\n        if not all([isinstance(options_for_provider, dict) for options_for_provider in provider_options]):\n            raise ValueError(\"'provider_options' values must be dicts.\")\n\n        for name, options in zip(providers, provider_options):\n            set_provider_options(name, options)\n\n    else:\n        for provider in providers:\n            if isinstance(provider, str):\n                set_provider_options(provider, dict())\n            elif (\n                isinstance(provider, tuple)\n                and len(provider) == 2\n                and isinstance(provider[0], str)\n                and isinstance(provider[1], dict)\n            ):\n                set_provider_options(provider[0], provider[1])\n            else:\n                raise ValueError(\"'providers' values must be either strings or (string, dict) tuples.\")\n\n    return list(provider_name_to_options.keys()), list(provider_name_to_options.values())\n\n\nclass Session:\n    \"\"\"\n    This is the main class used to run a model.\n    \"\"\"\n\n    def __init__(self):\n        # self._sess is managed by the derived class and relies on bindings from C.InferenceSession\n        self._sess = None\n        self._enable_fallback = True\n\n    def get_session_options(self):\n        \"Return the session options. See :class:`onnxruntime.SessionOptions`.\"\n        return self._sess_options\n\n    def get_inputs(self):\n        \"Return the inputs metadata as a list of :class:`onnxruntime.NodeArg`.\"\n        return self._inputs_meta\n\n    def get_outputs(self):\n        \"Return the outputs metadata as a list of :class:`onnxruntime.NodeArg`.\"\n        return self._outputs_meta\n\n    def get_overridable_initializers(self):\n        \"Return the inputs (including initializers) metadata as a list of :class:`onnxruntime.NodeArg`.\"\n        return self._overridable_initializers\n\n    def get_modelmeta(self):\n        \"Return the metadata. See :class:`onnxruntime.ModelMetadata`.\"\n        return self._model_meta\n\n    def get_providers(self):\n        \"Return list of registered execution providers.\"\n        return self._providers\n\n    def get_provider_options(self):\n        \"Return registered execution providers' configurations.\"\n        return self._provider_options\n\n    def set_providers(self, providers=None, provider_options=None):\n        \"\"\"\n        Register the input list of execution providers. The underlying session is re-created.\n\n        :param providers: Optional sequence of providers in order of decreasing\n            precedence. Values can either be provider names or tuples of\n            (provider name, options dict). If not provided, then all available\n            providers are used with the default precedence.\n        :param provider_options: Optional sequence of options dicts corresponding\n            to the providers listed in 'providers'.\n\n        'providers' can contain either names or names and options. When any options\n        are given in 'providers', 'provider_options' should not be used.\n\n        The list of providers is ordered by precedence. For example\n        `['CUDAExecutionProvider', 'CPUExecutionProvider']`\n        means execute a node using CUDAExecutionProvider if capable,\n        otherwise execute using CPUExecutionProvider.\n        \"\"\"\n        # recreate the underlying C.InferenceSession\n        self._reset_session(providers, provider_options)\n\n    def disable_fallback(self):\n        \"\"\"\n        Disable session.run() fallback mechanism.\n        \"\"\"\n        self._enable_fallback = False\n\n    def enable_fallback(self):\n        \"\"\"\n        Enable session.Run() fallback mechanism. If session.Run() fails due to an internal Execution Provider failure,\n        reset the Execution Providers enabled for this session.\n        If GPU is enabled, fall back to CUDAExecutionProvider.\n        otherwise fall back to CPUExecutionProvider.\n        \"\"\"\n        self._enable_fallback = True\n\n    def _validate_input(self, feed_input_names):\n        missing_input_names = []\n        for input in self._inputs_meta:\n            if input.name not in feed_input_names and not input.type.startswith(\"optional\"):\n                missing_input_names.append(input.name)\n        if missing_input_names:\n            raise ValueError(\n                f\"Required inputs ({missing_input_names}) are missing from input feed ({feed_input_names}).\"\n            )\n\n    def run(self, output_names, input_feed, run_options=None):\n        \"\"\"\n        Compute the predictions.\n\n        :param output_names: name of the outputs\n        :param input_feed: dictionary ``{ input_name: input_value }``\n        :param run_options: See :class:`onnxruntime.RunOptions`.\n        :return: list of results, every result is either a numpy array,\n            a sparse tensor, a list or a dictionary.\n\n        ::\n\n            sess.run([output_name], {input_name: x})\n        \"\"\"\n        self._validate_input(list(input_feed.keys()))\n        if not output_names:\n            output_names = [output.name for output in self._outputs_meta]\n        try:\n            return self._sess.run(output_names, input_feed, run_options)\n        except C.EPFail as err:\n            if self._enable_fallback:\n                print(f\"EP Error: {err!s} using {self._providers}\")\n                print(f\"Falling back to {self._fallback_providers} and retrying.\")\n                self.set_providers(self._fallback_providers)\n                # Fallback only once.\n                self.disable_fallback()\n                return self._sess.run(output_names, input_feed, run_options)\n            raise\n\n    def run_async(self, output_names, input_feed, callback, user_data, run_options=None):\n        \"\"\"\n        Compute the predictions asynchronously in a separate cxx thread from ort intra-op threadpool.\n\n        :param output_names: name of the outputs\n        :param input_feed: dictionary ``{ input_name: input_value }``\n        :param callback: python function that accept array of results, and a status string on error.\n            The callback will be invoked by a cxx thread from ort intra-op threadpool.\n        :param run_options: See :class:`onnxruntime.RunOptions`.\n\n        ::\n            class MyData:\n                def __init__(self):\n                    # ...\n                def save_results(self, results):\n                    # ...\n\n            def callback(results: np.ndarray, user_data: MyData, err: str) -> None:\n              if err:\n                 print (err)\n              else:\n                # save results to user_data\n\n            sess.run_async([output_name], {input_name: x}, callback)\n        \"\"\"\n        self._validate_input(list(input_feed.keys()))\n        if not output_names:\n            output_names = [output.name for output in self._outputs_meta]\n        return self._sess.run_async(output_names, input_feed, callback, user_data, run_options)\n\n    def run_with_ort_values(self, output_names, input_dict_ort_values, run_options=None):\n        \"\"\"\n        Compute the predictions.\n\n        :param output_names: name of the outputs\n        :param input_dict_ort_values: dictionary ``{ input_name: input_ort_value }``\n            See ``OrtValue`` class how to create `OrtValue`\n            from numpy array or `SparseTensor`\n        :param run_options: See :class:`onnxruntime.RunOptions`.\n        :return: an array of `OrtValue`\n\n        ::\n\n            sess.run([output_name], {input_name: x})\n        \"\"\"\n\n        def invoke(sess, output_names, input_dict_ort_values, run_options):\n            input_dict = {}\n            for n, v in input_dict_ort_values.items():\n                input_dict[n] = v._get_c_value()\n            result = sess.run_with_ort_values(input_dict, output_names, run_options)\n            if not isinstance(result, C.OrtValueVector):\n                raise TypeError(\"run_with_ort_values() must return a instance of type 'OrtValueVector'.\")\n            ort_values = [OrtValue(v) for v in result]\n            return ort_values\n\n        self._validate_input(list(input_dict_ort_values.keys()))\n        if not output_names:\n            output_names = [output.name for output in self._outputs_meta]\n        try:\n            return invoke(self._sess, output_names, input_dict_ort_values, run_options)\n        except C.EPFail as err:\n            if self._enable_fallback:\n                print(f\"EP Error: {err!s} using {self._providers}\")\n                print(f\"Falling back to {self._fallback_providers} and retrying.\")\n                self.set_providers(self._fallback_providers)\n                # Fallback only once.\n                self.disable_fallback()\n                return invoke(self._sess, output_names, input_dict_ort_values, run_options)\n            raise\n\n    def end_profiling(self):\n        \"\"\"\n        End profiling and return results in a file.\n\n        The results are stored in a filename if the option\n        :meth:`onnxruntime.SessionOptions.enable_profiling`.\n        \"\"\"\n        return self._sess.end_profiling()\n\n    def get_profiling_start_time_ns(self):\n        \"\"\"\n        Return the nanoseconds of profiling's start time\n        Comparable to time.monotonic_ns() after Python 3.3\n        On some platforms, this timer may not be as precise as nanoseconds\n        For instance, on Windows and MacOS, the precision will be ~100ns\n        \"\"\"\n        return self._sess.get_profiling_start_time_ns\n\n    def io_binding(self):\n        \"Return an onnxruntime.IOBinding object`.\"\n        return IOBinding(self)\n\n    def run_with_iobinding(self, iobinding, run_options=None):\n        \"\"\"\n        Compute the predictions.\n\n        :param iobinding: the iobinding object that has graph inputs/outputs bind.\n        :param run_options: See :class:`onnxruntime.RunOptions`.\n        \"\"\"\n        self._sess.run_with_iobinding(iobinding._iobinding, run_options)\n\n    def get_tuning_results(self):\n        return self._sess.get_tuning_results()\n\n    def set_tuning_results(self, results, *, error_on_invalid=False):\n        return self._sess.set_tuning_results(results, error_on_invalid)\n\n    def run_with_ortvaluevector(self, run_options, feed_names, feeds, fetch_names, fetches, fetch_devices):\n        \"\"\"\n        Compute the predictions similar to other run_*() methods but with minimal C++/Python conversion overhead.\n\n        :param run_options: See :class:`onnxruntime.RunOptions`.\n        :param feed_names: list of input names.\n        :param feeds: list of input OrtValue.\n        :param fetch_names: list of output names.\n        :param fetches: list of output OrtValue.\n        :param fetch_devices: list of output devices.\n        \"\"\"\n        self._sess.run_with_ortvaluevector(run_options, feed_names, feeds, fetch_names, fetches, fetch_devices)\n\n\nclass InferenceSession(Session):\n    \"\"\"\n    This is the main class used to run a model.\n    \"\"\"\n\n    def __init__(\n        self,\n        path_or_bytes: str | bytes | os.PathLike,\n        sess_options: Sequence[onnxruntime.SessionOptions] | None = None,\n        providers: Sequence[str | tuple[str, dict[Any, Any]]] | None = None,\n        provider_options: Sequence[dict[Any, Any]] | None = None,\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        :param path_or_bytes: Filename or serialized ONNX or ORT format model in a byte string.\n        :param sess_options: Session options.\n        :param providers: Optional sequence of providers in order of decreasing\n            precedence. Values can either be provider names or tuples of\n            (provider name, options dict). If not provided, then all available\n            providers are used with the default precedence.\n        :param provider_options: Optional sequence of options dicts corresponding\n            to the providers listed in 'providers'.\n\n        The model type will be inferred unless explicitly set in the SessionOptions.\n        To explicitly set:\n\n        ::\n\n            so = onnxruntime.SessionOptions()\n            # so.add_session_config_entry('session.load_model_format', 'ONNX') or\n            so.add_session_config_entry('session.load_model_format', 'ORT')\n\n        A file extension of '.ort' will be inferred as an ORT format model.\n        All other filenames are assumed to be ONNX format models.\n\n        'providers' can contain either names or names and options. When any options\n        are given in 'providers', 'provider_options' should not be used.\n\n        The list of providers is ordered by precedence. For example\n        `['CUDAExecutionProvider', 'CPUExecutionProvider']`\n        means execute a node using `CUDAExecutionProvider`\n        if capable, otherwise execute using `CPUExecutionProvider`.\n        \"\"\"\n        super().__init__()\n\n        if isinstance(path_or_bytes, (str, os.PathLike)):\n            self._model_path = os.fspath(path_or_bytes)\n            self._model_bytes = None\n        elif isinstance(path_or_bytes, bytes):\n            self._model_path = None\n            self._model_bytes = path_or_bytes  # TODO: This is bad as we're holding the memory indefinitely\n        else:\n            raise TypeError(f\"Unable to load from type '{type(path_or_bytes)}'\")\n\n        self._sess_options = sess_options\n        self._sess_options_initial = sess_options\n        self._enable_fallback = True\n        if \"read_config_from_model\" in kwargs:\n            self._read_config_from_model = int(kwargs[\"read_config_from_model\"]) == 1\n        else:\n            self._read_config_from_model = os.environ.get(\"ORT_LOAD_CONFIG_FROM_MODEL\") == \"1\"\n\n        # internal parameters that we don't expect to be used in general so aren't documented\n        disabled_optimizers = kwargs[\"disabled_optimizers\"] if \"disabled_optimizers\" in kwargs else None\n\n        try:\n            self._create_inference_session(providers, provider_options, disabled_optimizers)\n        except (ValueError, RuntimeError) as e:\n            if self._enable_fallback:\n                try:\n                    print(\"*************** EP Error ***************\")\n                    print(f\"EP Error {e} when using {providers}\")\n                    print(f\"Falling back to {self._fallback_providers} and retrying.\")\n                    print(\"****************************************\")\n                    self._create_inference_session(self._fallback_providers, None)\n                    # Fallback only once.\n                    self.disable_fallback()\n                    return\n                except Exception as fallback_error:\n                    raise fallback_error from e\n            # Fallback is disabled. Raise the original error.\n            raise e\n\n    def _create_inference_session(self, providers, provider_options, disabled_optimizers=None):\n        available_providers = C.get_available_providers()\n\n        # Tensorrt can fall back to CUDA if it's explicitly assigned. All others fall back to CPU.\n        if \"TensorrtExecutionProvider\" in available_providers:\n            if providers and any(\n                provider == \"CUDAExecutionProvider\"\n                or (isinstance(provider, tuple) and provider[0] == \"CUDAExecutionProvider\")\n                for provider in providers\n            ):\n                self._fallback_providers = [\"CUDAExecutionProvider\", \"CPUExecutionProvider\"]\n            else:\n                self._fallback_providers = [\"CPUExecutionProvider\"]\n        # MIGraphX can fall back to ROCM if it's explicitly assigned. All others fall back to CPU.\n        elif \"MIGraphXExecutionProvider\" in available_providers:\n            if providers and any(\n                provider == \"ROCMExecutionProvider\"\n                or (isinstance(provider, tuple) and provider[0] == \"ROCMExecutionProvider\")\n                for provider in providers\n            ):\n                self._fallback_providers = [\"ROCMExecutionProvider\", \"CPUExecutionProvider\"]\n            else:\n                self._fallback_providers = [\"CPUExecutionProvider\"]\n        else:\n            self._fallback_providers = [\"CPUExecutionProvider\"]\n\n        # validate providers and provider_options before other initialization\n        providers, provider_options = check_and_normalize_provider_args(\n            providers, provider_options, available_providers\n        )\n\n        session_options = self._sess_options if self._sess_options else C.get_default_session_options()\n\n        self._register_ep_custom_ops(session_options, providers, provider_options, available_providers)\n\n        if self._model_path:\n            sess = C.InferenceSession(session_options, self._model_path, True, self._read_config_from_model)\n        else:\n            sess = C.InferenceSession(session_options, self._model_bytes, False, self._read_config_from_model)\n\n        if disabled_optimizers is None:\n            disabled_optimizers = set()\n        elif not isinstance(disabled_optimizers, set):\n            # convert to set. assumes iterable\n            disabled_optimizers = set(disabled_optimizers)\n\n        # initialize the C++ InferenceSession\n        sess.initialize_session(providers, provider_options, disabled_optimizers)\n\n        self._sess = sess\n        self._sess_options = self._sess.session_options\n        self._inputs_meta = self._sess.inputs_meta\n        self._outputs_meta = self._sess.outputs_meta\n        self._overridable_initializers = self._sess.overridable_initializers\n        self._model_meta = self._sess.model_meta\n        self._providers = self._sess.get_providers()\n        self._provider_options = self._sess.get_provider_options()\n        self._profiling_start_time_ns = self._sess.get_profiling_start_time_ns\n\n    def _reset_session(self, providers, provider_options):\n        \"release underlying session object.\"\n        # meta data references session internal structures\n        # so they must be set to None to decrement _sess reference count.\n        self._sess_options = None\n        self._inputs_meta = None\n        self._outputs_meta = None\n        self._overridable_initializers = None\n        self._model_meta = None\n        self._providers = None\n        self._provider_options = None\n        self._profiling_start_time_ns = None\n\n        # create a new C.InferenceSession\n        self._sess = None\n        self._sess_options = self._sess_options_initial\n        self._create_inference_session(providers, provider_options)\n\n    def _register_ep_custom_ops(self, session_options, providers, provider_options, available_providers):\n        for i in range(len(providers)):\n            if providers[i] in available_providers and providers[i] == \"TensorrtExecutionProvider\":\n                C.register_tensorrt_plugins_as_custom_ops(session_options, provider_options[i])\n            elif (\n                isinstance(providers[i], tuple)\n                and providers[i][0] in available_providers\n                and providers[i][0] == \"TensorrtExecutionProvider\"\n            ):\n                C.register_tensorrt_plugins_as_custom_ops(session_options, providers[i][1])\n\n\nclass IOBinding:\n    \"\"\"\n    This class provides API to bind input/output to a specified device, e.g. GPU.\n    \"\"\"\n\n    def __init__(self, session: Session):\n        self._iobinding = C.SessionIOBinding(session._sess)\n        self._numpy_obj_references = {}\n\n    def bind_cpu_input(self, name, arr_on_cpu):\n        \"\"\"\n        bind an input to array on CPU\n        :param name: input name\n        :param arr_on_cpu: input values as a python array on CPU\n        \"\"\"\n        # Hold a reference to the numpy object as the bound OrtValue is backed\n        # directly by the data buffer of the numpy object and so the numpy object\n        # must be around until this IOBinding instance is around\n        self._numpy_obj_references[name] = arr_on_cpu\n        self._iobinding.bind_input(name, arr_on_cpu)\n\n    def bind_input(self, name, device_type, device_id, element_type, shape, buffer_ptr):\n        \"\"\"\n        :param name: input name\n        :param device_type: e.g. cpu, cuda, cann\n        :param device_id: device id, e.g. 0\n        :param element_type: input element type\n        :param shape: input shape\n        :param buffer_ptr: memory pointer to input data\n        \"\"\"\n        self._iobinding.bind_input(\n            name,\n            C.OrtDevice(\n                get_ort_device_type(device_type, device_id),\n                C.OrtDevice.default_memory(),\n                device_id,\n            ),\n            element_type,\n            shape,\n            buffer_ptr,\n        )\n\n    def bind_ortvalue_input(self, name, ortvalue):\n        \"\"\"\n        :param name: input name\n        :param ortvalue: OrtValue instance to bind\n        \"\"\"\n        self._iobinding.bind_ortvalue_input(name, ortvalue._ortvalue)\n\n    def synchronize_inputs(self):\n        self._iobinding.synchronize_inputs()\n\n    def bind_output(\n        self,\n        name,\n        device_type=\"cpu\",\n        device_id=0,\n        element_type=None,\n        shape=None,\n        buffer_ptr=None,\n    ):\n        \"\"\"\n        :param name: output name\n        :param device_type: e.g. cpu, cuda, cann, cpu by default\n        :param device_id: device id, e.g. 0\n        :param element_type: output element type\n        :param shape: output shape\n        :param buffer_ptr: memory pointer to output data\n        \"\"\"\n\n        # Follow the `if` path when the user has not provided any pre-allocated buffer but still\n        # would like to bind an output to a specific device (e.g. cuda).\n        # Pre-allocating an output buffer may not be an option for the user as :\n        # (1) They may not want to use a custom allocator specific to the device they want to bind the output to,\n        # in which case ORT will allocate the memory for the user\n        # (2) The output has a dynamic shape and hence the size of the buffer may not be fixed across runs\n        if buffer_ptr is None:\n            self._iobinding.bind_output(\n                name,\n                C.OrtDevice(\n                    get_ort_device_type(device_type, device_id),\n                    C.OrtDevice.default_memory(),\n                    device_id,\n                ),\n            )\n        else:\n            if element_type is None or shape is None:\n                raise ValueError(\"`element_type` and `shape` are to be provided if pre-allocated memory is provided\")\n            self._iobinding.bind_output(\n                name,\n                C.OrtDevice(\n                    get_ort_device_type(device_type, device_id),\n                    C.OrtDevice.default_memory(),\n                    device_id,\n                ),\n                element_type,\n                shape,\n                buffer_ptr,\n            )\n\n    def bind_ortvalue_output(self, name, ortvalue):\n        \"\"\"\n        :param name: output name\n        :param ortvalue: OrtValue instance to bind\n        \"\"\"\n        self._iobinding.bind_ortvalue_output(name, ortvalue._ortvalue)\n\n    def synchronize_outputs(self):\n        self._iobinding.synchronize_outputs()\n\n    def get_outputs(self):\n        \"\"\"\n        Returns the output OrtValues from the Run() that preceded the call.\n        The data buffer of the obtained OrtValues may not reside on CPU memory\n        \"\"\"\n        outputs = self._iobinding.get_outputs()\n        if not isinstance(outputs, C.OrtValueVector):\n            raise TypeError(\"get_outputs() must return an instance of type 'OrtValueVector'.\")\n        return [OrtValue(ortvalue) for ortvalue in outputs]\n\n    def get_outputs_as_ortvaluevector(self):\n        return self._iobinding.get_outputs()\n\n    def copy_outputs_to_cpu(self):\n        \"\"\"Copy output contents to CPU (if on another device). No-op if already on the CPU.\"\"\"\n        return self._iobinding.copy_outputs_to_cpu()\n\n    def clear_binding_inputs(self):\n        self._iobinding.clear_binding_inputs()\n\n    def clear_binding_outputs(self):\n        self._iobinding.clear_binding_outputs()\n\n\nclass OrtValue:\n    \"\"\"\n    A data structure that supports all ONNX data formats (tensors and non-tensors) that allows users\n    to place the data backing these on a device, for example, on a CUDA supported device.\n    This class provides APIs to construct and deal with OrtValues.\n    \"\"\"\n\n    def __init__(self, ortvalue, numpy_obj=None):\n        if isinstance(ortvalue, C.OrtValue):\n            self._ortvalue = ortvalue\n            # Hold a ref count to the numpy object if the OrtValue is backed directly\n            # by its data buffer so that it isn't destroyed when the OrtValue is in use\n            self._numpy_obj = numpy_obj\n        else:\n            # An end user won't hit this error\n            raise ValueError(\n                \"`Provided ortvalue` needs to be of type `onnxruntime.capi.onnxruntime_pybind11_state.OrtValue`\"\n            )\n\n    def _get_c_value(self):\n        return self._ortvalue\n\n    @staticmethod\n    def ortvalue_from_numpy(numpy_obj, device_type=\"cpu\", device_id=0):\n        \"\"\"\n        Factory method to construct an OrtValue (which holds a Tensor) from a given Numpy object\n        A copy of the data in the Numpy object is held by the OrtValue only if the device is NOT cpu\n\n        :param numpy_obj: The Numpy object to construct the OrtValue from\n        :param device_type: e.g. cpu, cuda, cann, cpu by default\n        :param device_id: device id, e.g. 0\n        \"\"\"\n        # Hold a reference to the numpy object (if device_type is 'cpu') as the OrtValue\n        # is backed directly by the data buffer of the numpy object and so the numpy object\n        # must be around until this OrtValue instance is around\n        return OrtValue(\n            C.OrtValue.ortvalue_from_numpy(\n                numpy_obj,\n                C.OrtDevice(\n                    get_ort_device_type(device_type, device_id),\n                    C.OrtDevice.default_memory(),\n                    device_id,\n                ),\n            ),\n            numpy_obj if device_type.lower() == \"cpu\" else None,\n        )\n\n    @staticmethod\n    def ortvalue_from_shape_and_type(shape=None, element_type=None, device_type=\"cpu\", device_id=0):\n        \"\"\"\n        Factory method to construct an OrtValue (which holds a Tensor) from given shape and element_type\n\n        :param shape: List of integers indicating the shape of the OrtValue\n        :param element_type: The data type of the elements in the OrtValue (numpy type)\n        :param device_type: e.g. cpu, cuda, cann, cpu by default\n        :param device_id: device id, e.g. 0\n        \"\"\"\n        if shape is None or element_type is None:\n            raise ValueError(\"`element_type` and `shape` are to be provided if pre-allocated memory is provided\")\n\n        return OrtValue(\n            C.OrtValue.ortvalue_from_shape_and_type(\n                shape,\n                element_type,\n                C.OrtDevice(\n                    get_ort_device_type(device_type, device_id),\n                    C.OrtDevice.default_memory(),\n                    device_id,\n                ),\n            )\n        )\n\n    @staticmethod\n    def ort_value_from_sparse_tensor(sparse_tensor):\n        \"\"\"\n        The function will construct an OrtValue instance from a valid SparseTensor\n        The new instance of OrtValue will assume the ownership of sparse_tensor\n        \"\"\"\n        return OrtValue(C.OrtValue.ort_value_from_sparse_tensor(sparse_tensor._get_c_tensor()))\n\n    def as_sparse_tensor(self):\n        \"\"\"\n        The function will return SparseTensor contained in this OrtValue\n        \"\"\"\n        return SparseTensor(self._ortvalue.as_sparse_tensor())\n\n    def data_ptr(self):\n        \"\"\"\n        Returns the address of the first element in the OrtValue's data buffer\n        \"\"\"\n        return self._ortvalue.data_ptr()\n\n    def device_name(self):\n        \"\"\"\n        Returns the name of the device where the OrtValue's data buffer resides e.g. cpu, cuda, cann\n        \"\"\"\n        return self._ortvalue.device_name().lower()\n\n    def shape(self):\n        \"\"\"\n        Returns the shape of the data in the OrtValue\n        \"\"\"\n        return self._ortvalue.shape()\n\n    def data_type(self):\n        \"\"\"\n        Returns the data type of the data in the OrtValue\n        \"\"\"\n        return self._ortvalue.data_type()\n\n    def element_type(self):\n        \"\"\"\n        Returns the proto type of the data in the OrtValue\n        if the OrtValue is a tensor.\n        \"\"\"\n        return self._ortvalue.element_type()\n\n    def has_value(self):\n        \"\"\"\n        Returns True if the OrtValue corresponding to an\n        optional type contains data, else returns False\n        \"\"\"\n        return self._ortvalue.has_value()\n\n    def is_tensor(self):\n        \"\"\"\n        Returns True if the OrtValue contains a Tensor, else returns False\n        \"\"\"\n        return self._ortvalue.is_tensor()\n\n    def is_sparse_tensor(self):\n        \"\"\"\n        Returns True if the OrtValue contains a SparseTensor, else returns False\n        \"\"\"\n        return self._ortvalue.is_sparse_tensor()\n\n    def is_tensor_sequence(self):\n        \"\"\"\n        Returns True if the OrtValue contains a Tensor Sequence, else returns False\n        \"\"\"\n        return self._ortvalue.is_tensor_sequence()\n\n    def numpy(self):\n        \"\"\"\n        Returns a Numpy object from the OrtValue.\n        Valid only for OrtValues holding Tensors. Throws for OrtValues holding non-Tensors.\n        Use accessors to gain a reference to non-Tensor objects such as SparseTensor\n        \"\"\"\n        return self._ortvalue.numpy()\n\n    def update_inplace(self, np_arr):\n        \"\"\"\n        Update the OrtValue in place with a new Numpy array. The numpy contents\n        are copied over to the device memory backing the OrtValue. It can be used\n        to update the input valuess for an InferenceSession with CUDA graph\n        enabled or other scenarios where the OrtValue needs to be updated while\n        the memory address can not be changed.\n        \"\"\"\n        self._ortvalue.update_inplace(np_arr)\n\n\nclass OrtDevice:\n    \"\"\"\n    A data structure that exposes the underlying C++ OrtDevice\n    \"\"\"\n\n    def __init__(self, c_ort_device):\n        \"\"\"\n        Internal constructor\n        \"\"\"\n        if isinstance(c_ort_device, C.OrtDevice):\n            self._ort_device = c_ort_device\n        else:\n            raise ValueError(\n                \"`Provided object` needs to be of type `onnxruntime.capi.onnxruntime_pybind11_state.OrtDevice`\"\n            )\n\n    def _get_c_device(self):\n        \"\"\"\n        Internal accessor to underlying object\n        \"\"\"\n        return self._ort_device\n\n    @staticmethod\n    def make(ort_device_name, device_id):\n        return OrtDevice(\n            C.OrtDevice(\n                get_ort_device_type(ort_device_name, device_id),\n                C.OrtDevice.default_memory(),\n                device_id,\n            )\n        )\n\n    def device_id(self):\n        return self._ort_device.device_id()\n\n    def device_type(self):\n        return self._ort_device.device_type()\n\n\nclass SparseTensor:\n    \"\"\"\n    A data structure that project the C++ SparseTensor object\n    The class provides API to work with the object.\n    Depending on the format, the class will hold more than one buffer\n    depending on the format\n    \"\"\"\n\n    def __init__(self, sparse_tensor):\n        \"\"\"\n        Internal constructor\n        \"\"\"\n        if isinstance(sparse_tensor, C.SparseTensor):\n            self._tensor = sparse_tensor\n        else:\n            # An end user won't hit this error\n            raise ValueError(\n                \"`Provided object` needs to be of type `onnxruntime.capi.onnxruntime_pybind11_state.SparseTensor`\"\n            )\n\n    def _get_c_tensor(self):\n        return self._tensor\n\n    @staticmethod\n    def sparse_coo_from_numpy(dense_shape, values, coo_indices, ort_device):\n        \"\"\"\n        Factory method to construct a SparseTensor in COO format from given arguments\n\n        :param dense_shape: 1-D  numpy array(int64) or a python list that contains a dense_shape of the sparse tensor\n            must be on cpu memory\n        :param values: a homogeneous, contiguous 1-D numpy array that contains non-zero elements of the tensor\n            of a type.\n        :param coo_indices:  contiguous numpy array(int64) that contains COO indices for the tensor. coo_indices may\n            have a 1-D shape when it contains a linear index of non-zero values and its length must be equal to\n            that of the values. It can also be of 2-D shape, in which has it contains pairs of coordinates for\n            each of the nnz values and its length must be exactly twice of the values length.\n        :param ort_device: - describes the backing memory owned by the supplied nummpy arrays. Only CPU memory is\n            suppored for non-numeric data types.\n\n        For primitive types, the method will map values and coo_indices arrays into native memory and will use\n        them as backing storage. It will increment the reference count for numpy arrays and it will decrement it\n        on GC. The buffers may reside in any storage either CPU or GPU.\n        For strings and objects, it will create a copy of the arrays in CPU memory as ORT does not support those\n        on other devices and their memory can not be mapped.\n        \"\"\"\n        return SparseTensor(\n            C.SparseTensor.sparse_coo_from_numpy(dense_shape, values, coo_indices, ort_device._get_c_device())\n        )\n\n    @staticmethod\n    def sparse_csr_from_numpy(dense_shape, values, inner_indices, outer_indices, ort_device):\n        \"\"\"\n        Factory method to construct a SparseTensor in CSR format from given arguments\n\n        :param dense_shape: 1-D numpy array(int64) or a python list that contains a dense_shape of the\n            sparse tensor (rows, cols) must be on cpu memory\n        :param values: a  contiguous, homogeneous 1-D numpy array that contains non-zero elements of the tensor\n            of a type.\n        :param inner_indices:  contiguous 1-D numpy array(int64) that contains CSR inner indices for the tensor.\n            Its length must be equal to that of the values.\n        :param outer_indices:  contiguous 1-D numpy array(int64) that contains CSR outer indices for the tensor.\n            Its length must be equal to the number of rows + 1.\n        :param ort_device: - describes the backing memory owned by the supplied nummpy arrays. Only CPU memory is\n            suppored for non-numeric data types.\n\n        For primitive types, the method will map values and indices arrays into native memory and will use them as\n        backing storage. It will increment the reference count and it will decrement then count when it is GCed.\n        The buffers may reside in any storage either CPU or GPU.\n        For strings and objects, it will create a copy of the arrays in CPU memory as ORT does not support those\n        on other devices and their memory can not be mapped.\n        \"\"\"\n        return SparseTensor(\n            C.SparseTensor.sparse_csr_from_numpy(\n                dense_shape,\n                values,\n                inner_indices,\n                outer_indices,\n                ort_device._get_c_device(),\n            )\n        )\n\n    def values(self):\n        \"\"\"\n        The method returns a numpy array that is backed by the native memory\n        if the data type is numeric. Otherwise, the returned numpy array that contains\n        copies of the strings.\n        \"\"\"\n        return self._tensor.values()\n\n    def as_coo_view(self):\n        \"\"\"\n        The method will return coo representation of the sparse tensor which will enable\n        querying COO indices. If the instance did not contain COO format, it would throw.\n        You can query coo indices as:\n\n        ::\n\n            coo_indices = sparse_tensor.as_coo_view().indices()\n\n        which will return a numpy array that is backed by the native memory.\n        \"\"\"\n        return self._tensor.get_coo_data()\n\n    def as_csrc_view(self):\n        \"\"\"\n        The method will return CSR(C) representation of the sparse tensor which will enable\n        querying CRS(C) indices. If the instance dit not contain CSR(C) format, it would throw.\n        You can query indices as:\n\n        ::\n\n            inner_ndices = sparse_tensor.as_csrc_view().inner()\n            outer_ndices = sparse_tensor.as_csrc_view().outer()\n\n        returning numpy arrays backed by the native memory.\n        \"\"\"\n        return self._tensor.get_csrc_data()\n\n    def as_blocksparse_view(self):\n        \"\"\"\n        The method will return coo representation of the sparse tensor which will enable\n        querying BlockSparse indices. If the instance did not contain BlockSparse format, it would throw.\n        You can query coo indices as:\n\n        ::\n\n            block_sparse_indices = sparse_tensor.as_blocksparse_view().indices()\n\n        which will return a numpy array that is backed by the native memory\n        \"\"\"\n        return self._tensor.get_blocksparse_data()\n\n    def to_cuda(self, ort_device):\n        \"\"\"\n        Returns a copy of this instance on the specified cuda device\n\n        :param ort_device: with name 'cuda' and valid gpu device id\n\n        The method will throw if:\n\n        - this instance contains strings\n        - this instance is already on GPU. Cross GPU copy is not supported\n        - CUDA is not present in this build\n        - if the specified device is not valid\n        \"\"\"\n        return SparseTensor(self._tensor.to_cuda(ort_device._get_c_device()))\n\n    def format(self):\n        \"\"\"\n        Returns a OrtSparseFormat enumeration\n        \"\"\"\n        return self._tensor.format\n\n    def dense_shape(self):\n        \"\"\"\n        Returns a numpy array(int64) containing a dense shape of a sparse tensor\n        \"\"\"\n        return self._tensor.dense_shape()\n\n    def data_type(self):\n        \"\"\"\n        Returns a string data type of the data in the OrtValue\n        \"\"\"\n        return self._tensor.data_type()\n\n    def device_name(self):\n        \"\"\"\n        Returns the name of the device where the SparseTensor data buffers reside e.g. cpu, cuda\n        \"\"\"\n        return self._tensor.device_name().lower()\n", 1028]}, "functions": {"_validate_input (C:\\workspace\\projects\\talk\\venv\\Lib\\site-packages\\onnxruntime\\capi\\onnxruntime_inference_collection.py:192)": ["C:\\workspace\\projects\\talk\\venv\\Lib\\site-packages\\onnxruntime\\capi\\onnxruntime_inference_collection.py", 192], "<listcomp> (C:\\workspace\\projects\\talk\\venv\\Lib\\site-packages\\onnxruntime\\capi\\onnxruntime_inference_collection.py:218)": ["C:\\workspace\\projects\\talk\\venv\\Lib\\site-packages\\onnxruntime\\capi\\onnxruntime_inference_collection.py", 218], "run (C:\\workspace\\projects\\talk\\venv\\Lib\\site-packages\\onnxruntime\\capi\\onnxruntime_inference_collection.py:202)": ["C:\\workspace\\projects\\talk\\venv\\Lib\\site-packages\\onnxruntime\\capi\\onnxruntime_inference_collection.py", 202]}}}